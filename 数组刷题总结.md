# Letcode-Array

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

** [IMG_7223.HEIC](../../..错误版本 1:**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len = 0;
        int maxLen = 0;
        int left = 0;
        int right = left + 1;
        while (right < s.length()) {
            if (s.length() == 1) {
                return 1;
            }else {
                if (s.charAt(right) != s.charAt(left)) {//这一步仅仅判断左右两端字符是否相同，当出现pwwkew时，无法通过。
                    right += 1;
                    len += 1;
                }else {
                    maxLen = len+1;
                    left += 1;
                    right += 1;
                }
            }
        }
        return maxLen;
    }
}
```

**错误版本 2：**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashSet<Character> chars = new HashSet<>();
        int left = 0, right = 0, maxLen = 0;
        while (right < s.length()){
            if (!chars.contains(s.charAt(right))){
                chars.add(s.charAt(right++));
            }else {
                chars.remove(s.charAt(left++));
            }
        }
        maxLen = Math.max(maxLen,chars.size());// 最大长度不应该在窗口滑动结束后更新，因为最后的窗口中的字符数小于最大长度
        return maxLen;
    }
}	
```

**正确版本 1：**

 ```java
 class Solution {
     public int lengthOfLongestSubstring(String s) {
         HashSet<Character> chars = new HashSet<>();
         int left = 0, right = 0, maxLen = 0;
         while (right < s.length()){
             if (!chars.contains(s.charAt(right))){
                 chars.add(s.charAt(right++));
             }else {
                 chars.remove(s.charAt(left++));
             }
             maxLen = Math.max(maxLen,chars.size());
         }
         return maxLen;
     }
 }
 //执行用时：6 ms, 在所有 Java 提交中击败了44.98%的用户
 //内存消耗：42.4 MB, 在所有 Java 提交中击败了21.92%的用户
 ```

**正确版本 2：**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
     int length = s.length();
        if (length == 0) {
            return 0;
        }
        int num = 1;
        int max = 1;
        for (int i = 1; i < length; i++) {
            int index = s.indexOf(s.charAt(i), i - num);
            if (i<=index) {
                num = num + 1;
            } else {
                num = i - index;
            }
            max = Math.max(max, num);
        }
        return max;
        }
}
//执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户
//内存消耗：40.5 MB, 在所有 Java 提交中击败了99.88%的用户
```

### **Hashset用法**

**知识点：**

HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。

HashSet 允许有 null 值。

HashSet 是无序的，即不会记录插入的顺序。

HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。

**对应类型：**

| 基本类型 | 引用类型  |
| :------: | :-------: |
| boolean  |  Boolean  |
|   byte   |   Byte    |
|  short   |   Short   |
|   int    |  Integer  |
|   long   |   Long    |
|  float   |   Float   |
|  double  |  Double   |
|   char   | Character |

**创建Hashset**

```java
HashSet<String> sites = new HashSet<String>();
//HashSet<引用类型> 名称 = new HashSet<引用类型>();
```

**常用方法**

```java
sites.add("Google");//添加元素
sites.contains("Taobao");//询问集合中是否存在某个元素
sites.remove("Taobao");//删除某个元素
sites.clear();//清空集合
sites.size();//输出集合尺寸
for (String i : sites) {//迭代遍历集合中的所有元素
	System.out.println(i);
}
System.out.println(sites);//直接输出集合中的所有元素
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 `target`，返回 `[-1, -1]`。你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 ：**

```java
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

从题目中看到，我们要输出的其实是`nums`中数值为`target`的下标，而并非真实位置。

**正确版本：**

```java
class Solution{
    int[] searchRange(int[] nums, int target){
        int leftIdx = searchLeft(nums,target);
        int rightIdx = searchRight(nums, target);
        if ((leftIdx == -2) || (rightIdx == -2)) return new int[] {-1,-1};//表示该数组中并没有这个数
        if ((rightIdx - leftIdx) > 1) return new int[]{leftIdx+1,rightIdx-1};//考虑到数组中只有一个数时的情况。
        return new int[]{-1,-1};
    }
    int searchLeft(int[] nums, int target){//与求右索引同理
        int left = 0, right = nums.length - 1, leftIdx = -2;
        while (left <= right){
            int mid  = (right + left)>>1;
            if (nums[mid] >= target){
                right = mid -1;
                leftIdx = right;
            }else {
                left = mid + 1;
            }
        }
        return leftIdx;
    }
    int searchRight(int[] nums, int target){
        int left = 0, right = nums.length - 1, rightIdx = -2;//定义左右指针和右索引的标记值
        while (left <= right){// 采用左闭右闭
            int mid = (right + left)>>1;//位运算加快速度
            if (nums[mid] <= target){//由于数组非降序，因此当中间值小于或等于target，也就说明下标大于mid的数组中的数都会大于target。为什么不能小于呢？这么想：[5,7,7,8,8,10]，我们要返回最靠近8的右边的数字的序号值，如果小于的话，也就是说mid后面的数字可能会等于8
                left = mid + 1;//更新左指针，此时[mid + 1, right]中所有的值都大于target
                rightIdx = left;
            }else {
                right = mid -1;
            }
        }
        return rightIdx;
    }
}
```

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ...,nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例：**

```java
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

这里有一个细节，每次二分之后，我们总能够得到一个升序排列的数组，另一边可能升序也有可能不升序。这个时候我们只需要判断两个区间哪个是升序区间和target是否属于升序区间即可。

**正确版本**

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        if (nums.length ==0){//排除数组为空的情况
            return -1;
        }
        if (nums.length == 1){//排除数组中只有一个数的情况
            return target == nums[0]? 0:-1;
        }
        while (left <= right){//双向指针求取区间的分界值
            int mid = (left+right)/2;
            if (nums[mid] == target){//中点刚好等于target
                return mid;
            }
            if (nums[0] <= nums[mid]){//左半边有序，因为数组原本就是升序数组，当旋转过后右边那部分的值不可能大于nums[0]
                if ((nums[0] <= target) && (target < nums[mid])){//target在左半边区间内
                        right = mid -1;
                    }else {//如果不在左半边区间，对右半边区间进行二分
                        left = mid + 1;
                    }
            }else {
                // 错误一：target <= nums[right]写成了target < nums[right]
                if ((nums[mid] < target) && (target <= nums[right])){//右半边有序，与左半边有序同理
                    left = mid + 1;
                }else {
                    right = mid -1;
                }
            }
        }
        return -1;
    }
}	
```

**思考**

使用二分法的前提是数组有序，当出现这种有序数组被某种方式打乱成无序数组时，找到其中有序的部分随后进行二分可以有效解决问题，

## [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

编写一个高效的算法来判断 `m x n` 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。

**示例 ：**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```java
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

从规律上来说，我们只需要分别行和列分别进行二分即可，首先确定这个值所在的行之后，对该行进行二分，从而找到这个值是否在矩阵当中。

**正确版本**

```java
class Solution {
public boolean searchMatrix(int[][] matrix, int target) {
    if(matrix[0][0]>target || matrix[matrix.length-1][matrix[0].length-1]< target){//确认target在矩阵内部
        return false;
    }
    int row = searchRow(matrix, target);//找到target所在行
    return searchColumn(matrix, target, row);//该行是否存在该值

}

boolean searchColumn(int[][] matrix, int target, int row) {
    int left = 0, right = matrix[row].length - 1;
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (matrix[row][mid] == target) {
            return true;
        } else if (matrix[row][mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;
}

int searchRow(int[][] matrix, int target) {
    int low = 0, high = matrix.length - 1;
    while (low <= high) {
        int mid = (low + high) >> 1;
        if (matrix[mid][0] == target) {
            return mid;
        } else if (matrix[mid][0] < target) {//中间值小于target，说明比mid小的所有行中的数都小于target，开始往下半区挪动区间
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return high;//此时返回的high实际上是mid - 1，此时比mid大的行数中所有值都是大于target的
}
}
```

## [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组`[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**正确版本**

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        int min = nums[right];//首先确定一个最小值
        while (left <= right){
            int mid = (left + right) //分成两段
            if(nums[mid] <= min){//只要nums[mid]小于或者等于min，就说明mid之后的数组是有序的
                min = nums[mid];
                right = mid - 1;
            }else {//大于的话就不断压缩右半区空间
                left = mid + 1;
            }
        }
        return min;
    }
}
```

## [1482. 制作 m 束花所需的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)

给你一个整数数组 `bloomDay`，以及两个整数 `m` 和 `k` 。现需要制作 `m` 束花。制作花束时，需要使用花园中 **相邻的 `k` 朵花** 。花园中有 `n` 朵花，第 `i` 朵花会在 `bloomDay[i]` 时盛开，**恰好** 可以用于 **一束** 花中。请你返回从花园中摘 `m` 束花需要等待的最少的天数。如果不能摘到 `m` 束花则返回 **-1** 。

**示例 ：**

```java
输入：bloomDay = [1,10,3,10,2], m = 3, k = 1
输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
```

二分法的变体，关键还是在check函数上，最少天数和总天数肯定是确定的，根据天数进行二分，当mid满足条件时，压缩区间。

**正确版本**

```java
class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        if (bloomDay.length/k < m) return -1;//花园中花的数目少于我们要制作的花束数
        int left = Arrays.stream(bloomDay).min().getAsInt(), right = Arrays.stream(bloomDay).max().getAsInt();//找到两个边界
        while (left < right){//二分法找满足条件的天数
            int mid = (left + right) >> 1;
            if (findDay(bloomDay,mid,m,k)){
                right = mid;//注意到这里，满足该条件时不会对mid-1，因为减去1之后区间内可能会不存在能够符合题意的天数
            }else {
                left = mid + 1;//不满足条件可以放心+1
            }
        }
        return left;//这个很容易理解，循环终止时left肯定是等于right的
    }
    boolean findDay(int[] bloomDay, int mid, int m, int k){//check函数需要的参数肯定要加上一个mid的，通过不断更新满足条件的天数找到最小天数
        int flowerNums = 0;//初始化相邻花的数量
        int bouquet = 0;//初始化花的束数
        for (int i = 0; (i < bloomDay.length) & (bouquet < m); i++) {//遍历花数数组
            if (bloomDay[i] <= mid){//判断第i朵花是否开花
                flowerNums++;
                if (flowerNums == k){//判断是否满足花束条件
                    bouquet++;
                    flowerNums=0;
                }
            }else {
                flowerNums = 0;
            }
        }
        return bouquet >= m;
    }
}
```

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。**说明：**你不能倾斜容器。

**示例 1：**

![image-20230606002223025](https://gitee.com/wenliang_zeng/md/raw/master/image-20230606002223025.png)

```java
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

这题需要做的是如何在不丢失所有可能的情况下得到所有结果。我们要求的是最大蓄水量，这个蓄水量取决于两根柱子中较短的那根柱子的高度，这样的话我们每次从两个柱子中短的那根柱子压缩就可以了。

**正确版本：**

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length-1, maxArea = -1;//首先找到左右边界
        while (left < right){
            int high = (height[left] > height[right] ? height[right] : height[left]);//找到两根柱子中较高的柱子
            int area = high*(right-left);//计算此时的面积
            maxArea = maxArea > area ? maxArea :area;//更新面积
            while (height[left] <= high && left < right) left++;//压缩区间
            while (height[right] <= high && left < right) right--;
        }
        return maxArea;
    }
}	
```

## [825. 适龄的朋友](https://leetcode.cn/problems/friends-of-appropriate-ages/)

在社交媒体网站上有 `n` 个用户。给你一个整数数组 `ages` ，其中 `ages[i]` 是第 `i` 个用户的年龄。

如果下述任意一个条件为真，那么用户 `x` 将不会向用户 `y`（`x != y`）发送好友请求：

- `ages[y] <= 0.5 * ages[x] + 7`
- `ages[y] > ages[x]`
- `ages[y] > 100 && ages[x] < 100`

否则，`x` 将会向 `y` 发送一条好友请求。

注意，如果 `x` 向 `y` 发送一条好友请求，`y` 不必也向 `x` 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

**示例**

```java
输入：ages = [16,16]
输出：2
解释：2 人互发好友请求。
```

这题最关键的是要发现`ages[y] <= 0.5 * ages[x] + 7`

**正确版本**

```java
class Solution {
    public int numFriendRequests(int[] ages) {
        Arrays.sort(ages);
        int left = 0, right = 0, allContact = 0;
        for (int age : ages){
            if (age < 15) continue;
            while (ages[left] <= 0.5*age+7) left++;
            while (right+1 < ages.length&&ages[right+1]<= age) right++;
            allContact += (right - left);
        }
        return allContact;
    }
}
```

